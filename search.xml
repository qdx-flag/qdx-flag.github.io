<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客开源</title>
      <link href="/2021/08/27/blog-open-source/"/>
      <url>/2021/08/27/blog-open-source/</url>
      
        <content type="html"><![CDATA[<h1 id="效果演示（洪卫博客）"><a href="#效果演示（洪卫博客）" class="headerlink" title="效果演示（洪卫博客）"></a>效果演示（洪卫博客）</h1><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://raw.githubusercontent.com/shw2018/cdn/master/blog_files/img/Blog-Open-Source/blog-demo1.gif" alt="演示Demo"></p><h1 id="简短介绍"><a href="#简短介绍" class="headerlink" title="简短介绍"></a>简短介绍</h1><p>使用了洪卫的博客开源，<br>我的网站倒腾了一两周总算把个人博客网站完善了，目前这个版本使用应该是够了，当然还有一些优化项和功能增加后续在慢慢更新，为了回馈开源，今天准备把我自己修改完善的<code>blog</code>网站源代码开源。这不是生成后的网页文件，是您可以直接使用的源码，您只需要把博客相关信息换成您自己的就可以部署了，对于新手或者不懂编程的小伙伴来说，简直是福音，极大简化了您构建博客的工作量和复杂度，每个人都可以下载并修改成自己喜欢样式！如果你有修改想法，欢迎PR！最后，我们还是给这个开源小项目取个名字吧，就叫<a href="https://github.com/shw2018/hexo-blog-fly.git" target="_blank" rel="noopener">hexo-blog-fly</a>吧，怎么样？&lt;&lt;&lt;&lt;&lt;<a href="https://github.com/shw2018/hexo-blog-fly" target="_blank" rel="noopener">源代码下载</a>&gt;&gt;&gt;&gt;&gt;</p><p>本博客基于<code>Hexo</code>框架搭建，用到<a href="https://github.com/shw2018/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a>主题, 并在此基础之上做了很多修改，修复了一些bug，增加了一些新的特性和功能，博客地址：<a href="https://shw2018.github.io/" target="_blank" rel="noopener">https://shw2018.github.io</a>，博客演示：<a href="https://sunhwee.com" target="_blank" rel="noopener">sunhwee.com</a>。</p><hr><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>原主题特性</strong>:</p><ul><li><p>简单漂亮，文章内容美观易读</p></li><li><p><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a> 设计</p></li><li><p>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</p></li><li><p>首页轮播文章及每天动态切换 <code>Banner</code> 图片</p></li><li><p>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</p></li><li><p>时间轴式的归档页</p></li><li><p><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</p></li><li><p>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</p></li><li><p>可自定义的数据的友情链接页面</p></li><li><p>支持文章置顶和文章打赏</p></li><li><p>支持 <code>MathJax</code></p></li><li><p><code>TOC</code> 目录</p></li><li><p>可设置复制文章内容时追加版权信息</p></li><li><p>可设置阅读文章时做密码验证</p></li><li><p><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>、<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 和 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</p></li><li><p>集成了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</p></li><li><p>支持在首页的音乐播放和视频播放功能</p><p><strong>增加的工作或特性(未打钩的是已做但还没更新到源码的)</strong>:</p></li><li><p>修改了原主题的一些很多<code>bug</code>   2019.08.05</p></li><li><p>加入图片懒加载功能，在根目录配置文件开启和关闭    2019.08.09</p></li><li><p>增加<code>留言板</code>功能          2019.08.05</p></li><li><p>在关于板块,加入<code>简历</code>功能页   2019.08.05</p></li><li><p>增加视听[视觉听觉影音]板块       2019.08.10</p></li><li><p>支持<code>emoji</code>表情，用<code>markdown emoji</code>语法书写直接生成对应的能<strong>跳跃</strong>的表情。  2019.08.10</p></li><li><p>增加网站运行时间显示  2019.08.10</p></li><li><p>增加<code>动漫模型</code>     2019.08.10</p></li><li><p>整体替换Banner图片和文章特色图片   2019.08.10</p></li><li><p>增加分类<code>相册</code>功能         2019.08.29</p></li><li><p>去掉标签页,将其合并至<code>分类</code>页中                2019.09.01</p></li><li><p>修改了一些控件的参数   2019.09.01</p></li><li><p>修改部分样式,比如: 文章卡片,固定高度,使其不至于因为文章摘要的长短不同导致卡片大小不一使页面布局很不美观,类似的还有友链卡片,优化了页面内容布局,视觉更整齐美观          2019.09.01</p></li><li><p>解决首页文章列表卡片上方 <code>border-radius</code>圆角失效的bug  2019.09.01</p></li><li><p>添加页面樱花飘落动效            2019.09.09</p></li><li><p>添加鼠标点击烟花爆炸动效   2019.09.09</p></li><li><p>加入天气接口控件   2019.09.09</p></li><li><p>加入鼠标点击文字特效   2019.09.10</p></li><li><p>添加页面雪花飘落动效            2019.09.10</p></li><li><p>添加在线聊天插件            2019.09.12</p></li><li><p>持续更新…</p></li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>更多详情教程，强烈推荐看我写的：<a href="https://sunhwee.com/posts/6e8839eb.html" target="_blank" rel="noopener">Hexo+Github博客搭建完全教程</a></strong></p></blockquote><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件安装与配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/2021/01/30/vue/"/>
      <url>/2021/01/30/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="简短介绍"><a href="#简短介绍" class="headerlink" title="简短介绍"></a>简短介绍</h1><p><code>Vue.js</code> 是一个渐进式 <code>JavaScript</code> 框架，主要用于构建用户界面。它的设计哲学是“自底向上渐进式”，这意味着开发者可以根据项目需求，从简单的页面增强到复杂的单页面应用<code>（SPA）</code>。Vue.js 既轻量易用，又功能强大，吸收了 <code>Angular</code> 和 <code>React</code> 的优点。<br><code>学习是一项长期的任务，让我来一起成长吧！</code></p><hr><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h2 id="vue和react有什么不同"><a href="#vue和react有什么不同" class="headerlink" title="vue和react有什么不同"></a>vue和react有什么不同</h2><ol><li><strong>设计哲学</strong><br><code>Vue.js</code></li></ol><ul><li>渐进式框架：<code>Vue</code> 是一个渐进式框架，意味着你可以从简单的项目开始，并逐步引入更多功能和工具，如 <code>Vue Router</code>（路由）和 <code>Pinia/Vuex</code>（状态管理），从而使框架适应项目的复杂性。<br>双向数据绑定：Vue 提供了内置的双向数据绑定，使得开发表单或用户输入等场景更加简便。<br><code>React.js</code></li></ul><p><code>UI 库</code>：<code>React</code> 更像是一个 UI 库，只关注视图层。它的设计是“一个函数输入状态，返回一个 UI”，强调函数式编程思想。开发者需要使用其他库来完成路由、状态管理等任务。<br><code>单向数据流</code>：<code>React</code> 强调单向数据流（Unidirectional Data Flow），数据只能从父组件传递到子组件。状态管理通常通过 <code>Redux</code> 或其他库实现。</p><ol start="2"><li><strong>模板语法 vs JSX</strong><br><code>Vue.js</code><br><code>模板语法</code>：Vue 使用了模板和指令（例如 v-if、v-for）来定义 UI。它的模板语法类似于标准的 HTML，开发者可以使用简单的 HTML 结构来声明组件的视图逻辑。<br><code>单文件组件（SFC</code>）：Vue 支持在 .vue 文件中写组件，文件包含 <code>&lt;template&gt;、&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>，使得结构清晰且便于管理。</li></ol><p><code>React.js</code><br><code>JSX</code>：React 使用 <code>JSX（JavaScript XML）</code>，它允许在 <code>JavaScript</code> 代码中直接编写类似 <code>HTML</code> 的结构。<code>JSX</code> 本质上是语法糖，开发者需要掌握 <code>JavaScript</code> 和 <code>React</code> 的概念来有效使用 JSX。<br>全部 JavaScript：<code>React 的开发风格更贴近纯 JavaScript</code>，所有的逻辑和模板都混合在 JavaScript 中。这给开发者提供了极大的灵活性和控制力。</p><ol start="3"><li><strong>数据流和状态管理</strong><br><code>Vue.js</code><br><code>双向数据绑定</code>：<code>Vue</code> 使用双向数据绑定机制，可以轻松处理表单元素的状态同步，尤其在小型项目中非常方便。<br><code>Vuex/Pinia</code>状态管理：对于大型项目，<code>Vue</code> 提供了 <code>Vuex</code>或 <code>Pinia</code> 作为集中式的状态管理工具，可以与 Vue 的响应式系统无缝集成。</li></ol><p><code>React.js</code><br><code>单向数据流</code>：React 强调单向数据流，组件之间的数据传递只能从父到子，状态的更新必须通过传递函数实现。<br>外部状态管理库（如 <code>Redux、Recoil</code> 等）：React 没有内置的全局状态管理工具，通常依赖第三方库来管理复杂的状态（如 Redux、Recoil 或 Context API）。</p><ol start="4"><li><strong>虚拟 DOM</strong><br><code>Vue.js</code><br>Vue 也使用了虚拟 DOM 来优化性能。但 Vue 的模板语法抽象了底层的虚拟 <code>DOM</code> 实现，开发者无需直接操作虚拟 DOM。</li></ol><p><code>React.js</code><br><code>React 是虚拟 DOM 的发明者</code>，JSX 最终被编译成虚拟 <code>DOM</code> 的结构。React 的开发者可以直接操作虚拟 DOM，虽然这不常见，但它的使用灵活性很高。</p><ol start="5"><li><strong>性能和优化</strong></li></ol><ul><li><code>Vue.js</code></li></ul><p><code>Vue</code> 的响应式系统在精确追踪组件的依赖关系方面表现出色，只会重新渲染需要更新的组件，减少了不必要的性能消耗。<br>Vue 内置了更多优化措施，尤其在 <code>Vue 3</code> 中，借助 <code>Proxy</code> 实现了更精细的响应追踪，提升了性能。</p><p><code>React.js</code><br>React 的性能优化主要依赖虚拟 <code>DOM</code> 和 <code>shouldComponentUpdate</code> 或 <code>React.memo</code> 等手动控制更新的机制。React 鼓励开发者在必要时进行性能优化，但需要更多手动干预。<br>React 在大型应用中的性能优化依赖开发者对组件的渲染流程有更多控制权。</p><ol start="6"><li><strong>学习曲线</strong><br><code>Vue.js</code><br>Vue 的学习曲线较平滑，开发者可以使用简单的模板语法和指令开始构建应用。其清晰的文档和一致的 API 使得新手容易上手。<br>Vue 的渐进式特性允许开发者在项目中逐步引入更多复杂的功能，而不必一开始就掌握整个框架。</li></ol><p><code>React.js</code><br>React 的学习曲线较陡峭，开发者需要学习 JSX、组件生命周期、函数式编程以及状态管理工具（如 Redux）才能更高效地使用 React。<br>虽然一开始可能复杂，但 React 提供了更高的灵活性和控制力，适合构建高度定制化的应用。</p><ol start="7"><li><strong>生态系统</strong><br><code>Vue.js</code><br>Vue 的生态系统相对集中，官方工具如 Vue Router、Pinia（或 Vuex）等都是 Vue 核心团队维护的，集成非常紧密。<br>Vue 在亚洲，尤其是在中国有非常广泛的使用和支持，社区非常活跃。</li></ol><p><code>React.js</code><br>React 的生态系统庞大且分散。React 本身只专注于视图层，开发者需要依赖第三方库（如 Redux、React Router 等）来构建完整的应用。<br>React 在全球范围内，尤其是西方市场有广泛的支持，社区活跃度和招聘需求很高。</p><ol start="8"><li><strong>使用场景</strong><br><code>Vue.js</code><br>适合小到中型的项目，或者需要快速开发、交付的项目。Vue 的渐进式架构也适合大型项目，但在非常复杂的应用中可能不如 React 灵活。</li></ol><p><code>React.js</code><br>适合大型复杂的项目，尤其是需要高度定制和灵活控制的场景。React 的灵活性让它成为构建复杂应用的热门选择。</p><p><code>总结</code><br><code>Vue.js</code>：更适合初学者，学习成本较低，适合快速开发和中小型项目。其组件化和双向数据绑定让开发变得简单高效，尤其适合需要快速上手并交付的项目。</p><p><code>React.js</code>：适合有经验的开发者，学习曲线较陡，但提供了更大的灵活性和控制权，适合大型、复杂的项目。React 的强大生态系统和组件复用能力使其在大型企业应用中广泛使用。</p><p>两者都是非常优秀的前端框架，选择 Vue 还是 React 主要取决于项目需求、团队经验和个人喜好。</p><hr><h2 id="什么是虚拟dom"><a href="#什么是虚拟dom" class="headerlink" title="什么是虚拟dom"></a>什么是虚拟dom</h2><p><strong>虚拟 DOM (Virtual DOM) 是一种在现代前端框架（如 Vue、React）中广泛使用的概念，它是对实际 DOM 的一种抽象表示，目的是提高网页的渲染性能。</strong></p><ol><li><p><em>DOM 与性能瓶颈</em><br>在传统的网页开发中，<code>DOM</code>（文档对象模型）是 HTML 页面的结构化表示，它允许 <code>JavaScript</code> 操作 <code>HTML</code> 元素。然而，操作 <code>DOM</code> 是昂贵的，因为每次更新 DOM 都会触发浏览器的<code>重排/回流（reflow）</code>和<code>重绘（repaint）</code>，尤其是当页面复杂或更新频繁时，性能开销非常大。</p></li><li><p><em>虚拟 DOM 的工作原理</em><br><code>虚拟 DOM</code> 是对<code>真实 DOM</code>的一种轻量级的表示，它是一个<code>JavaScript 对象</code>，保留了 DOM 的结构和属性。前端框架使用虚拟 <code>DOM</code> 来追踪界面的状态变化，并通过以下步骤高效更新真实 <code>DOM</code>：</p></li></ol><ul><li><p>创建虚拟 DOM：当组件状态或数据发生变化时，框架会首先在内存中创建一个虚拟 DOM 树，而不是立即更新真实 DOM。</p></li><li><p>比较差异（Diffing）：<code>框架通过一种高效的diff 算法比较新旧虚拟 DOM 树</code>，找到哪些节点发生了变化。</p></li><li><p>最小化更新（Patch）：根据 diff 算法的结果，<code>框架只更新那些需要变动的真实 DOM 部分</code>，而不是整个页面重新渲染。</p></li></ul><ol start="3"><li>优势</li></ol><ul><li>减少直接 DOM 操作：<code>通过 diff 算法减少不必要的 DOM 更新</code>，<code>避免频繁的 reflow 和 repaint</code>。</li><li>提升性能：由于大多数变化都可以在内存中处理，<code>只有当必要时才操作真实 DOM，整体性能显著提升</code>。</li><li>更流畅的用户体验：减少不必要的 DOM 操作能带来更流畅的用户交互体</li></ul><hr><h2 id="删除数组用delete和Vue-delete有什么区别？"><a href="#删除数组用delete和Vue-delete有什么区别？" class="headerlink" title="删除数组用delete和Vue.delete有什么区别？"></a>删除数组用delete和Vue.delete有什么区别？</h2><p><strong>响应式支持：</strong><br><code>delete</code>：不会触发 Vue 响应式系统，<code>因此不会自动更新视图</code>。<br><code>Vue.delete</code>：会触发 Vue 响应式系统，<code>视图自动更新</code>。</p><p><strong>数组处理：</strong><br><code>delete</code>：删除后数组长度不变，<code>留下 "empty slot"</code>。<br><code>Vue.delete</code>：删除后数组长度变化，<code>移除元素并调整数组</code>。</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">let arr = [1, 2, 3];delete arr[1]; // 删除数组中的第二个元素console.log(arr); // 输出: [1, empty, 3]// Vue.deletelet vm = new Vue({  data: {    arr: [1, 2, 3]  }});Vue.delete(vm.arr, 1); // 删除数组中的第二个元素console.log(vm.arr); // 输出: [1, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="watch和computed的区别？"><a href="#watch和computed的区别？" class="headerlink" title="watch和computed的区别？"></a>watch和computed的区别？</h2><ol><li><strong>computed（计算属性）</strong><br><code>computed</code> 是基于依赖的 缓存 计算属性，通常用于<code>依赖其他数据</code>的值计算。它们在依赖的数据发生变化时才会重新计算，<code>并且结果会被缓存</code>，直到依赖的数据再次发生变化。</li></ol><ol start="2"><li><strong>watch（侦听器）</strong><br><code>watch</code> 用于 观察 一个响应式数据的变化，并在数据变化时执行特定的回调函数。它可以<code>执行异步操作和复杂的逻辑</code>，特别适合需要在<code>数据变化时进行 副作用操作</code> 的场景，比如请求 API、手动执行某些逻辑等。</li></ol><hr><h2 id="v-for没有key回发生什么？"><a href="#v-for没有key回发生什么？" class="headerlink" title="v-for没有key回发生什么？"></a>v-for没有key回发生什么？</h2><ul><li>没有 key 可能会导致 <code>数据渲染错误</code> 和 <code>组件状态混乱</code>，尤其是在列表数据发生变动时。</li><li>缺少 key 还会导致 Vue 的 <code>diff 算法性能下降</code>，因为 <code>Vue 无法有效地追踪和复用 DOM 元素</code>。</li><li>应该始终为 v-for 列表中的每个项提供一个唯一的 key 属性，确保 Vue 能够正确地管理 DOM 更新。</li></ul><hr><h2 id="vue的双向绑定原理"><a href="#vue的双向绑定原理" class="headerlink" title="vue的双向绑定原理"></a>vue的双向绑定原理</h2><p>Vue 的双向绑定是通过以下几部分组成的：</p><ol><li><strong>数据劫持（Data Observer）：</strong><br>Vue 利用 <code>Object.defineProperty() (Vue 2)</code> 或 <code>Proxy (Vue 3)</code> 劫持对象的属性，监听对属性的读写操作。通过这种方式，Vue 能够在数据被访问或修改时触发相关的逻辑。<pre class="line-numbers language-javaScript"><code class="language-javaScript">// Vue 2.x 响应式数据劫持Object.defineProperty(obj, 'message', {get() { // 依赖收集 return value;},set(newValue) { // 通知更新 value = newValue;}});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>// Vue 3.x 响应式数据劫持<br>const observed = new Proxy(obj, {<br>  get(target, key) {<br>    // 依赖收集<br>    return Reflect.get(target, key);<br>  },<br>  set(target, key, value) {<br>    // 通知更新<br>    return Reflect.set(target, key, value);<br>  }<br>});</p><pre><code>2. **发布-订阅模式：**Vue 内部实现了一个 `发布-订阅模式`，每个数据都有一个对应的 `依赖收集器（Dep`）。当数据发生变化时，Dep 会通知所有依赖于它的`订阅者（通常是渲染函数或组件）`，触发视图更新。3. **模板编译：**Vue 会在编译模板时生成渲染函数，这个渲染函数会被绑定到相应的数据上。当数据变化时，渲染函数重新执行，从而更新视图。4. **Watcher 监听器：**`Watcher` 是 Vue 中负责侦听数据变化的部分。每一个组件实例都会创建与之相关的 Watcher 实例，它会观察某个数据或表达式，一旦数据发生变化，`Watcher` 会收到通知并触发视图更新或用户定义的回调函数。---## Vue3.0里为什么要用Proxy代替defineProperty?1. **监听数组和对象新增、删除属性的能力**在 `Vue 2.x` 中，`Object.defineProperty()` 只能劫持已经存在的属性，无法监听对象新增或删除的属性。为了解决这个问题，Vue 2.x 需要使用 `Vue.set `和 `Vue.delete` 来手动添加或删除响应式属性。这在开发中既繁琐又容易出错。而 `Proxy` 可以直接拦截`对象的任意操作`，`包括新增和删除属性`。因此在 Vue 3 中，代理对象不再需要特殊的 `Vue.set` 或 `Vue.delete` 方法来处理新增或删除属性。```javascript// Vue 3 中使用 Proxy 可以监听属性新增、删除const obj = new Proxy({}, {  get(target, key) {    // 处理属性访问    return target[key];  },  set(target, key, value) {    // 处理属性设置    target[key] = value;    return true;  },  deleteProperty(target, key) {    // 处理属性删除    delete target[key];    return true;  }});</code></pre><ol start="2"><li><strong>性能优势</strong><br>由于 <code>Proxy</code> 不需要递归遍历对象的每一个属性，并且可以通过一次代理完成对整个对象的劫持，因此在处理大型对象时性能有明显提升。此外，<code>Proxy</code> 提供了更高效的方式来处理对象的<code>新增、删除、数组</code>操作等，使得响应式系统的性能更加稳定和高效。</li></ol><ol start="3"><li><strong>代理更多的操作</strong><br><code>Object.defineProperty()</code> 只能拦截属性的 <code>get</code> 和 <code>set</code> 操作，而 <code>Proxy</code> 可以拦截更多种类的操作，如：<br><code>has</code>：检测属性是否存在，如 in 操作符。<br><code>deleteProperty</code>：拦截属性删除操作。<br><code>ownKeys</code>：拦截对象的属性枚举操作，如 <code>Object.keys()</code>。<br><code>defineProperty</code>：拦截 <code>Object.defineProperty()</code> 调用。<br><code>getOwnPropertyDescriptor</code>：拦截 <code>Object.getOwnPropertyDescriptor()</code>。<br>通过 Proxy，Vue 3 可以更灵活、全面地监控和控制对象的操作，从而构建出更强大和高效的响应式系统。</li></ol><hr><h2 id="Vue3-0编译做了哪些优化"><a href="#Vue3-0编译做了哪些优化" class="headerlink" title="Vue3.0编译做了哪些优化"></a>Vue3.0编译做了哪些优化</h2><ol><li><p><strong>编译器重写</strong><br><code>Vue 3.0</code>的编译器经过了完全重写，采用了<code>模块化的设计</code>，允许编译器的不同部分能够单独使用或扩展。新的编译器生成的代码更加高效，占用更少的空间，从而提高了<code>渲染性能</code>。重写后的编译器具备了更好的<code>可扩展性和维护性</code>，<code>支持更复杂的模板语法</code>和更强大的优化能力。</p></li><li><p><strong>静态提升</strong><br>Vue 3.0 编译器会对模板中的静态内容进行<code>“静态提升”</code>，即将那些不会改变的静态节点提升到渲染函数的外部。这意味着这些静态节点只会被创建一次，而不会在每次渲染时重新创建，从而减少了<code>虚拟 DOM 的创建和渲染开销</code>。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// Vue 2.x 渲染函数</span><span class="token keyword">return</span> <span class="token punctuation">{</span>tag<span class="token punctuation">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>children<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token punctuation">{</span> tag<span class="token punctuation">:</span> <span class="token string">'span'</span><span class="token punctuation">,</span> children<span class="token punctuation">:</span> <span class="token string">'Hello World'</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 每次渲染都会重新创建</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>// Vue 3.0 渲染函数<br>const staticNode = { tag: ‘span’, children: ‘Hello World’ }; // 静态提升<br>return {<br>  tag: ‘div’,<br>  children: [staticNode] // 每次渲染只复用 staticNode<br>}</p><p>```</p><ol start="3"><li><strong>静态节点标记</strong><br><code>Vue 3.0</code>中，编译器会为模板中的静态节点打上标记，告诉<code>虚拟 DOM</code>渲染引擎哪些节点是静态的，哪些是动态的。通过这种标记，Vue 可以在更新时<code>跳过静态节点</code>，从而减少不必要的更新操作。对于大多数不变的 <code>DOM 结构</code>，这大大提升了渲染效率。</li></ol><ul><li><code>Patch Flags</code>：精准的 DOM 更新，提高运行时效率。</li><li>响应式系统优化：基于 <code>Proxy</code>，性能更优，精确性更高。</li><li>多根节点（Fragment）支持：减少 DOM 层级复杂度。</li><li>Slot 渲染优化：<code>静态 Slot 缓存</code>，动态 Slot 精准处理。</li><li>事件处理优化： 缓存静态事件，减少重复绑定。</li><li>更好的 TypeScript 支持：开发体验和代码质量提升。</li><li>编译缓存：避免重复编译带来的性能开销。</li></ul><hr><h2 id="Vue3新特性–Composition-API与React-Hooks的异同点"><a href="#Vue3新特性–Composition-API与React-Hooks的异同点" class="headerlink" title="Vue3新特性–Composition API与React Hooks的异同点"></a>Vue3新特性–Composition API与React Hooks的异同点</h2><p>Vue 3 的 Composition API 和 React 的 Hooks 都是为了提高组件逻辑复用性、代码组织性以及灵活性而引入的特性，它们的核心思想类似，但在实现方式、使用场景和具体设计上也有一些不同。</p><p><strong>共同点</strong></p><ol><li><p><code>逻辑复用与抽离</code>：<br>Vue 3 的 <code>Composition API</code> 和 <code>React Hooks</code> 都能将组件中的逻辑抽离出来，方便复用。通过这两者，开发者可以更好地组织和复用复杂的状态逻辑，而<code>不是像传统方式一样将代码堆积在生命周期函数中</code>。<br>两者都可以用于抽象组件的逻辑，将<code>状态管理、事件处理、数据获取</code>等功能拆分成更小的模块。</p></li><li><p><code>基于函数的 API：</code><br><code>Composition API</code> 和 <code>Hooks</code> 都是基于函数的 API，通过调用函数来获取响应式状态、方法或者生命周期逻辑。<br>两者的 API 都提倡用函数的方式来处理状态和副作用，而不是像传统 <code>Vue</code>的 <code>data、methods、computed</code> 等选项式 API 或者<code>React 类组件的 state 和 setState</code>。</p></li><li><p><code>轻松组合逻辑：</code><br><code>Composition API 和 Hooks</code> 都支持将不同功能的逻辑组合在一起，方便处理复杂的组件逻辑。你可以将多个功能模块化后，再在一个组件中组合它们，组件的可读性和可维护性也随之提升。</p></li></ol><p><strong>不同点：</strong></p><ol><li>Vue 3 的 <code>Composition API 拥有 Vue 内置的响应式系统</code>，状态变更会自动触发更新；而 React Hooks 则依赖组件重新渲染来更新状态。</li><li>Vue 的 Composition API 提供了更多内置功能，如 <code>watch、computed、响应式系统</code>等；React Hooks 则<code>更加轻量，需要开发者</code>用其他库或工具来实现类似的功能。</li></ol><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><!-- <table>  <tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp" ></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp" ></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png" ></td>     </tr></table> --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2020/08/30/javascript-copy/"/>
      <url>/2020/08/30/javascript-copy/</url>
      
        <content type="html"><![CDATA[<h1 id="简短介绍"><a href="#简短介绍" class="headerlink" title="简短介绍"></a>简短介绍</h1><p><code>JavaScript</code> 是一门用来与网页交互的脚本语言，包含以下三个组成部分。<br> 1、ECMAScript：由 ECMA-262 定义并提供核心功能。<br> 2、文档对象模型（DOM）：提供与网页内容交互的方法和接口。<br> 3、浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。<br>JavaScript 的这三个部分得到了五大 <code>Web</code> 浏览器<code>（IE、Firefox、Chrome、Safari 和 Opera）</code>不同程度<br>的支持。所有浏览器基本上对 <code>ES5（ECMAScript 5）</code>提供了完善的支持，而对 <code>ES6（ECMAScript 6）</code>和<br><code>ES7（ECMAScript 7）</code>的支持度也在不断提升。这些浏览器对 DOM 的支持各不相同，但对 Level 3 的支<br>持日益趋于规范。<code>HTML5</code> 中收录的 <code>BOM</code> 会因浏览器而异，不过开发者仍然可以假定存在很大一部分<br>公共特性。<br><code>学习是一项长期的任务，让我来一起成长吧！</code></p><hr><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h2 id="JavaScript的数据类型有哪些？引用类型有哪些？"><a href="#JavaScript的数据类型有哪些？引用类型有哪些？" class="headerlink" title="JavaScript的数据类型有哪些？引用类型有哪些？"></a>JavaScript的数据类型有哪些？引用类型有哪些？</h2><p>  JavaScript 中的数据类型可以分为两类：<code>基本类型（原始类型）</code>和 <code>引用类型</code>。</p><ul><li><p>原始类型：Number, String, Boolean, null,undefined, Symbol, BigInt。</p></li><li><p>引用类型：Object, Array, Function, Date, RegExp, Map, Set</p><hr><h2 id="如何判断JavaScript的数据类型"><a href="#如何判断JavaScript的数据类型" class="headerlink" title="如何判断JavaScript的数据类型"></a>如何判断JavaScript的数据类型</h2></li></ul><ol><li>使用 <code>typeof</code> 运算符<pre class="line-numbers language-javascript"><code class="language-javascript">   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// "bigint"</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// "object"</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// "object" (数组也是对象)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>使用 <code>instanceof</code> 运算符<pre class="line-numbers language-javascript"><code class="language-javascript">   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>使用 <code>Object.prototype.toString.call()</code> 方法<pre class="line-numbers language-javascript"><code class="language-javascript">   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "[object Array]"</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "[object Object]"</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "[object Function]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>使用 <code>Array.isArray()</code> 方法<pre class="line-numbers language-javascript"><code class="language-javascript">   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// true</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><ul><li>原始类型可以使用 typeof 进行判断，但对于 null 和数组的判断不够准确。</li><li>引用类型可以使用 instanceof 和 Array.isArray() 进行判断，或者通过 Object.prototype.toString.call() 来进行更准确的判断。</li><li>结合不同的方法，可以实现更灵活和准确的数据类型判断。</li></ul><hr><h2 id="怎么判断两个对象相等？如何判断空对象？"><a href="#怎么判断两个对象相等？如何判断空对象？" class="headerlink" title="怎么判断两个对象相等？如何判断空对象？"></a>怎么判断两个对象相等？如何判断空对象？</h2><ol><li><p><code>比较对象的属性</code></p><ul><li><p>要判断两个对象的属性是否相等，可以遍历它们的属性，逐一比较值。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">isEqual</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 如果两个对象的引用相同，则直接返回 true</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj1 <span class="token operator">===</span> obj2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 如果两个对象其中一个不是对象，或者它们的类型不同，返回 false</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj1 <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> obj2 <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> obj1 <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> obj2 <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 获取两个对象的属性名数组</span>  <span class="token keyword">const</span> keys1 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> keys2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 如果属性数量不同，返回 false</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>keys1<span class="token punctuation">.</span>length <span class="token operator">!==</span> keys2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 遍历属性并递归比较</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> keys1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果 obj2 中没有 obj1 的某个属性，或者属性值不相等，返回 false</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>keys2<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">isEqual</span><span class="token punctuation">(</span>obj1<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> obj2<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 示例</span><span class="token keyword">const</span> objA <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span> c<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> objB <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span> c<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isEqual</span><span class="token punctuation">(</span>objA<span class="token punctuation">,</span> objB<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><pre><code>2. `判断空对象`- 要判断一个对象是否为空对象（即没有任何可枚举的属性），可以使用 `Object.keys()` 或 `Object.getOwnPropertyNames()` 来获取对象的属性，然后判断属性数组是否为空。```javascript  // 遍历keys  function isEmptyObject(obj) {    // 判断是否为对象，且是否为空    return obj &amp;&amp; Object.keys(obj).length === 0 &amp;&amp; obj.constructor === Object;  }  // 示例  console.log(isEmptyObject({}));      // true  console.log(isEmptyObject({ a: 1 })); // false</code></pre><hr><h2 id="0-1-0-2为什么不等于0-3？"><a href="#0-1-0-2为什么不等于0-3？" class="headerlink" title="0.1+0.2为什么不等于0.3？"></a>0.1+0.2为什么不等于0.3？</h2><p><em>原理解释</em></p><ul><li>在二进制表示中，像 0.1 和 0.2 这样的十进制小数不能被精确表示。它们在二进制中是无限循环的数值，因此被截断为近似值。这种近似值在计算时会引发精度误差。</li></ul><p>举个例子：</p><ul><li>0.1 在二进制中的表示是：0.0001100110011001100110011001100110011001100110011001101（无限循环）</li><li>0.2 在二进制中的表示是：0.001100110011001100110011001100110011001100110011001101（无限循环）<br>当你进行 0.1 + 0.2 的计算时，JavaScript 将近似值相加，结果是 0.30000000000000004，这和你期望的 0.3 不完全相等。</li></ul><pre class="line-numbers language-javascript"><code class="language-javascript">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 输出 0.30000000000000004</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">===</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><em>如何解决</em><br>为了避免这种精度问题，通常会使用四舍五入的方法来修正计算结果。例如，可以使用 <code>toFixed()</code> 方法或 <code>Number.EPSILON</code> 来比较两个浮点数：</p><pre class="line-numbers language-javascript"><code class="language-javascript">    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 四舍五入保留 1 位小数</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sum <span class="token operator">===</span> <span class="token string">'0.3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 输出 true</span>    <span class="token comment" spellcheck="true">// 使用 Number.EPSILON （允许小误差）</span>    <span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;</span> Number<span class="token punctuation">.</span>EPSILON<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="如何判断一个对象是否为空对象？"><a href="#如何判断一个对象是否为空对象？" class="headerlink" title="如何判断一个对象是否为空对象？"></a>如何判断一个对象是否为空对象？</h2><p><em>方法一：使用<code>for...in</code>循环</em></p><pre class="line-numbers language-javascript"><code class="language-javascript">  <span class="token comment" spellcheck="true">// 遍历keys</span>  <span class="token keyword">function</span> <span class="token function">isEmptyObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">isEqual</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;</span> Number<span class="token punctuation">.</span>EPSILON<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isEqual</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出 true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="强制类型转换、隐式类型转换分别是什么？场景说明"><a href="#强制类型转换、隐式类型转换分别是什么？场景说明" class="headerlink" title="强制类型转换、隐式类型转换分别是什么？场景说明"></a>强制类型转换、隐式类型转换分别是什么？场景说明</h2><ol><li>强制类型转换，也称为显式类型转换，是通过开发者手动调用函数或运算符来将一个值转换为所需的类型。常见的类型转换包括将值转换为字符串、数字或布尔值。</li></ol><p><em>常见的强制类型转换方法：</em></p><ul><li>转换为字符串：使用 String() 函数或调用 toString() 方法</li><li>转换为数字：使用 Number()、parseInt()、parseFloat() 函数</li><li>转换为布尔值：使用 Boolean() 函数<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 将数字转换为字符串 （互转）</span><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// str = "123"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 "string"</span><span class="token comment" spellcheck="true">// 将值转换为布尔值</span><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">let</span> isTrue <span class="token operator">=</span> <span class="token function">Boolean</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// isTrue = false, 因为 0 转换为 false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isTrue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出 false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>2.隐式类型转换，也称为自动类型转换，是 JavaScript 在遇到不同类型的值时自动进行的类型转换。它通常发生在算术运算、比较操作等场景下。</p><p><em>常见的隐式类型转换：</em></p><ul><li>数字与字符串混合运算时，JavaScript 会将数字转换为字符串进行拼接</li><li>使用双等号 == 进行比较时，JavaScript 会自动进行类型转换以比较值</li><li>在条件语句中，非布尔类型会被自动转换为布尔类型</li></ul><pre class="line-numbers language-javascript"><code class="language-javascript">  <span class="token comment" spellcheck="true">// 字符串与数字相加</span>  <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">"5"</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> num <span class="token operator">+</span> str<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "10" + "5" -> "105" （字符串拼接）</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出 "105"</span>  <span class="token comment" spellcheck="true">// 双等号比较</span>  <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num <span class="token operator">==</span> bool<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出 true，因为 `true` 被转换为 1</span>  <span class="token comment" spellcheck="true">// 条件语句中的隐式转换</span>  <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"True"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"False"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出 "False"，因为空字符串被转换为 `false`</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>总结：</code></p><ul><li>强制类型转换：开发者主动调用函数将数据类型显式转换。</li><li>隐式类型转换：JavaScript 自动转换类型，可能导致意外的结果。</li></ul><hr><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="===和==的区别"></a>===和==的区别</h2><ul><li><p><code>===</code>：严格相等，不会进行类型转换，只有当值和类型都相等时才返回 true。</p></li><li><p><code>==</code>：宽松相等，允许类型转换，会将两个值的类型转换为相同类型后再进行比较。</p><pre class="line-numbers language-javaScript"><code class="language-javaScript">  1 === 1;         // true  1 === '1';       // false (不同类型，一个是数字，一个是字符串)  true === 1;      // false (布尔值与数字不同类型)  null === undefined; // false (不同类型)  // ==   0 == false;      // true (0 被转换为 false)  0 === false;     // false (不同类型)  [] == false;     // true (空数组被转换为 false)  [] === false;    // false (不同类型)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>总结：<code>=== 更严格、更安全</code>，而 <code>== 允许隐式类型转换</code>，但可能导致意外行为。</p></li></ul><hr><h2 id="元素拖动如何实现，实现原理"><a href="#元素拖动如何实现，实现原理" class="headerlink" title="元素拖动如何实现，实现原理"></a>元素拖动如何实现，实现原理</h2><p><strong>实现步骤</strong></p><ol><li><code>监听 mousedown 事件</code>：当用户按下鼠标时，记录鼠标当前位置，并开始监听鼠标移动事件。</li><li><code>监听 mousemove 事件</code>：在鼠标移动过程中，计算鼠标的位移并更新元素的位置，使其跟随鼠标移动。</li><li><code>监听 mouseup 事件</code>：当鼠标松开时，停止移动操作，移除鼠标移动的监听器。</li></ol><p><strong>实现原理</strong></p><ol><li><p>获取初始位置：<br>当用户按下鼠标（<code>mousedown</code>）时，获取当前鼠标相对于页面的坐标，记录元素的初始位置。</p></li><li><p>计算位移并更新位置：</p></li></ol><p>在鼠标移动时（<code>mousemove</code>），不断获取新的鼠标位置，计算与初始按下时的差值，更新元素的 left 和 top 样式，使元素随着鼠标移动。</p><ol start="3"><li>结束拖动：<br>当用户松开鼠标（<code>mouseup</code>），停止监听 mousemove 事件。</li></ol><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">        <span class="token selector"><span class="token id">#draggable</span> </span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>            <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>            <span class="token property">cursor</span><span class="token punctuation">:</span> grab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Draggable Element<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>draggable<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Drag me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">const</span> draggable <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'draggable'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> offsetX<span class="token punctuation">,</span> offsetY<span class="token punctuation">,</span> isDragging <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当鼠标按下时</span>        draggable<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousedown'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            isDragging <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            offsetX <span class="token operator">=</span> event<span class="token punctuation">.</span>clientX <span class="token operator">-</span> draggable<span class="token punctuation">.</span>offsetLeft<span class="token punctuation">;</span>            offsetY <span class="token operator">=</span> event<span class="token punctuation">.</span>clientY <span class="token operator">-</span> draggable<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>            draggable<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cursor <span class="token operator">=</span> <span class="token string">'grabbing'</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 防止文本选择</span>            event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当鼠标移动时</span>        document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>isDragging<span class="token punctuation">)</span> <span class="token punctuation">{</span>                draggable<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>clientX <span class="token operator">-</span> offsetX<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>                draggable<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>clientY <span class="token operator">-</span> offsetY<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当鼠标松开时</span>        document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mouseup'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            isDragging <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            draggable<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cursor <span class="token operator">=</span> <span class="token string">'grab'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h2><ol><li><strong>节流: 降低用户事件响应的频率（节流是指在规定的时间间隔内，只执行一次操作）</strong><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">let</span> lastTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">const</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> lastTime <span class="token operator">>=</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>         lastTime <span class="token operator">=</span> now<span class="token punctuation">;</span>         func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>// 使用<br>window.addEventListener(‘scroll’, throttle(() =&gt; {<br>    console.log(‘Throttled scroll event’);<br>}, 1000));</p><pre><code>2. **防抖: 只响应最后一个用户事件（只有在规定的时间内没有再次触发）**```javascriptfunction debounce(func, delay) {    let timer;    return function(...args) {        clearTimeout(timer);        timer = setTimeout(() =&gt; {            func.apply(this, args);        }, delay);    };}// 使用const input = document.getElementById('searchInput');input.addEventListener('input', debounce(() =&gt; {    console.log('Debounced input event');}, 500));</code></pre><p><strong>结合场景选择</strong></p><ul><li><code>节流：适合持续触发的场景，例如滚动、拖拽等事件，避免处理函数的频繁调用而影响性能。</code></li><li><code>防抖：适合非持续触发的场景，例如搜索框输入、表单校验等，只有在用户停止输入后才执行操作。</code></li></ul><hr><h2 id="promise-和-async-await的关系"><a href="#promise-和-async-await的关系" class="headerlink" title="promise 和 async/await的关系"></a>promise 和 async/await的关系</h2><ul><li><code>Promise</code> 是异步处理的基础，它通过 <code>.then()</code> 和 <code>.catch()</code> 来处理异步操作及其结果。</li><li><code>async/await</code> 是基于 <code>Promise</code> 的<code>语法糖</code>，使得异步代码看起来像同步代码，减少嵌套和复杂的链式调用，提高了代码的可读性和维护性。</li></ul><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Data fetched'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 'Data fetched'</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="webworker"><a href="#webworker" class="headerlink" title="webworker"></a>webworker</h2><ol><li><p><strong>什么是 Web Worker？</strong><br><code>Web Worker</code> 是一个独立的 <code>JavaScript`` 线程，与主线程并行执行代码。它不能直接操作</code>DOM<code>，但可以通过消息传递机制与主线程通信。</code>Web Worker<code>的主要用途是在后台运行长时间运行的</code>JavaScript` 任务，例如数据处理、文件解析等，避免在主线程上执行这些操作时出现界面卡顿的问题。</p></li><li><p><strong>Web Worker 的特性</strong></p></li></ol><ul><li><p><em>独立运行</em>：<code>Web Worker</code> 运行在浏览器的单独线程中，不影响主线程（也就是 UI 线程）的执行。主线程负责<code>处理用户交互</code>和 <code>DOM</code> 操作，而 <code>Web Worker</code> 运行复杂计算、数据处理等。</p></li><li><p><em>无法访问 DOM</em>：<code>Web Worker</code> 不能直接访问和操作 <code>DOM</code> 元素，因此它不适合处理与用户界面直接相关的操作。</p></li><li><p><em>消息传递</em>：主线程和 <code>Web Worker</code> 之间通过 <code>postMessage</code> 和 <code>onmessage</code> 进行通信。主线程可以向 <code>Worker</code> 发送消息，<code>Worker</code> 可以返回结果。</p></li><li><p><em>异步执行</em>：因为 <code>Worker</code> 运行在独立的线程中，执行是异步的，主线程不会被阻塞。</p></li></ul><p><strong>3.1 创建 Worker 文件</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// worker.js</span>self<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取主线程发送过来的数据</span>    <span class="token keyword">const</span> data <span class="token operator">=</span> event<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 执行复杂的任务</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        result <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将结果发送回主线程</span>    self<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.2 在主线程中使用 Worker</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// main.js</span><span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">'worker.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 向 Worker 发送消息</span>worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token number">1000000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接收来自 Worker 的结果</span>worker<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Worker 计算结果:'</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 处理 Worker 错误</span>worker<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Worker 出错:'</span><span class="token punctuation">,</span> error<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Web Worker 允许在主线程之外运行 JavaScript 代码，用于处理后台的复杂计算任务，避免阻塞用户界面。</li><li>通信机制：主线程和 Worker 通过 postMessage 传递消息，不能直接访问 DOM。</li><li>适用场景：适合处理长时间的计算、数据处理任务，提高页面性能和用户体验</li></ul><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> javaScript学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
